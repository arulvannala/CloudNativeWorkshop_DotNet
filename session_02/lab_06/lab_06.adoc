= Lab 6 - Understanding Fortune Teller and ASP.NET Core Dependency Injection

[abstract]
--
Starting with this lab we will begin creating a fully functional Fortune Teller application which uses several of the Steeltoe components.
You have two paths you can follow when doing the rest of the labs for the workshop:

. For each lab, open up and work with finished lab code. With this path, you won't be writing any new code, you will just be reviewing and running already completed lab code.
. Open the FortuneTeller solution as the starting project and begin adding code for each of the labs. With this path, you will be writing new code and debugging what you write.

The goals for Lab 6 is to understand ASP.NET Core dependency injection and to use it to wire up two areas of the code:

. For the Fortune Teller Service:
.. We need to wire up the ``IFortuneRepository`` to the ``FortuneController`` and modify the ``FortuneController`` to use the ``FortuneRepository``
.. We need to add the ``IFortuneRepository`` and the ``FortuneContext`` to the service container.
.. Initialize the ``FortuneContext`` with some Fortunes.
. For the Fortune Teller UI:
.. We need to wire up the ``IFortuneService`` to the ``FortuneController`` and modify the ``FortuneController`` to use the ``IFortuneService``.
.. We need to add the ``IFortuneService`` to the service container.
--

== Open VS2015 Solution
. Start VS2015 and open the solution you wish to start from:
.. _Workshop/Session-02/Lab06.sln_ if you want to start with finished code.
.. _Workshop/FortuneTeller/FortuneTeller.sln_ if you will be writing code from scratch.

=== Understanding Fortune-Teller-Service project
. Expand the Fortune-Teller-Service project
. Open and examine ``Program.cs``, as everything starts in here.
.. Examine the usage of ``WebHostBuilder``, ``UseKestrel``, ``UseUrls``, ``UseStartup<Startup>``.
. Open and examine ``Startup.cs`` as this is where the app is configured.
.. Examine the ``Startup`` constructor, where the apps configuration is read and created.
.. Examine the ``ConfigureService()`` method, where the services are added to the DI container.
.. Examine the ``Configure()`` method, where middleware is added to the request processing pipeline.
. Open the ``Models`` folder which holds the code for the ``IFortuneRepository``
.. Examine ``IFortuneRepository``
.. Examine ``FortuneRepository``, the implementation and notice it uses a ``FortuneContext``
.. Examine ``FortuneContext``, notice it is a context based on ``EntityFrameworkCore``
... Notice it stores ``FortuneEntity``
.. Examine ``SampleData`` and notice ``InitializeFortunesAsync`` method which adds sample data to the ``FortuneContext``
. Open the ``Controllers`` folder which holds the MVC Controller code
.. Open the ``FortunesController``, the implementation for the Rest API exposed by this microservice
.. Notice it implments the ``IFortuneService`` which provides the two endpoints
... AllFortunesAsync() ->  GET: api/fortunes/all
... RandomFortuneAsync() -> GET api/fortunes/random
.. Notice the controller methods return hard-coded ``Fortunes``, not ``FortuneEntitys``.

=== Understanding Fortune-Teller-UI project
. Expand the Fortune-Teller-UI project
. Open and examine ``Program.cs``, as everything starts in here.
.. Examine the usage of ``WebHostBuilder``, ``UseKestrel``, ``UseUrls``, ``UseStartup<Startup>``.
. Open and examine ``Startup.cs`` as this is where the app is configured.
.. Examine the ``Startup`` constructor, where the apps configuration is read and created.
.. Examine the ``ConfigureService()`` method, where the services are added to the DI container.
.. Examine the ``Configure()`` method, where middleware is added to the request processing pipeline.
. Open the ``Common/Services`` folder which holds the code for the ``IFortuneService``
.. Examine ``IFortuneService``
.. Examine ``FortuneServiceClient``, the implementation and notice it returns hard-coded ``Fortunes``
. Open the ``Controllers`` folder which holds the MVC Controller code
.. Open the ``FortunesController``, the implementation for the UI
.. Notice the ``RandomFortune`` action, it returns a ``Fortune`` to the View
. Open the ``Views/Fortunes`` folder which holds the Views for the FortuneController
.. Open ``RandomFortune``, the View used by the ``RandomFortune`` action
... Notice how it uses the ``Fortune`` returned from the action

=== Modify Fortune Teller Service

==== Step 01 - Modify FortuneController to use the IFortuneRepository
. To get the ``IFortuneRepository`` into the controller we need to add a constructor to the ``FortuneController``:
+
----
        private IFortuneRepository _fortunes;
        public FortunesController(IFortuneRepository fortunes)
        {
            _fortunes = fortunes;
        }
----
. Then to get ``FortuneController`` to use the ``IFortuneRepository`` we have to modify both contoller actions.
Something like below should work, but feel free to write your own code:
+
----
        // GET: api/fortunes/all
        [HttpGet("all")]
        public async Task<List<Fortune>> AllFortunesAsync()
        {
            var entities = await _fortunes.GetAllAsync();
            var result = new List<Fortune>();
            foreach(var entity in entities)
            {
                result.Add(new Fortune() { Id = entity.Id, Text = entity.Text });
            }
            return result;
        }
        // GET api/fortunes/random
        [HttpGet("random")]
        public async Task<Fortune> RandomFortuneAsync()
        {
            var entity = await _fortunes.RandomFortuneAsync();
            return new Fortune() { Id = entity.Id, Text = entity.Text };
        }
----
==== Step 02 - Add IFortuneRepository and FortuneContext to Service Container
. To get the ``IFortuneRepository`` into the service container we need to modify the ``Startup`` class method ``ConfigureServices`` and add ``IFortuneRepository`` as a Singleton created from its implementation ``FortuneRepository``.
+
----
        public void ConfigureServices(IServiceCollection services)
        {
            .....

            services.AddSingleton<IFortuneRepository, FortuneRepository>();

            // Add framework services.
            services.AddMvc();
        }
----
. But notice that the ``FortuneRepository`` takes a ``FortuneContex``t as a argument to its constructor.
So we also need to add a ``FortuneContext`` to the container.
But ``FortuneContext`` is built using the EntityFrameworkCore so we also need to add it to the container as well.
We do that with the ``AddEntityFramework()`` method below.
Once these services are added, then we also need to configure the ``FortuneContext`` to use some backend database for storage.
At this point in the lab, we will configure it to use an in-memory collection.
In an upcoming lab, we will use Steeltoe connectors to connect it to a real database.
+
----
        public void ConfigureServices(IServiceCollection services)
        {
            .....
            services.AddEntityFramework()
                    .AddDbContext<FortuneContext>(options => options.UseInMemoryDatabase());
            services.AddSingleton<IFortuneRepository, FortuneRepository>();

            // Add framework services.
            services.AddMvc();
        }
----

==== Step 03 - Initialize FortuneContext with some Fortunes
. To add some Fortunes to the ``FortuneContext`` we have already written the code for you. You can make use of the static method ``SampleData.InitializeFortunesAsync()`` to do this.
The question is, where do you add this? Have a look at the method and notice that the code asks the container for an instance of ``FortuneContext`` in order to initialize it with samples.
As a result, the container needs to be built before we call this method and also before we start handling any requests.
So the best place to add this call is in the ``Configure`` method in the ``Startup`` class.
+
----
        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
        {
            loggerFactory.AddConsole(Configuration.GetSection("Logging"));

            app.UseMvc();

            SampleData.InitializeFortunesAsync(app.ApplicationServices).Wait();
        }
----

==== Run Locally
. Using the skills you learned from Lab05, run the app from VS2015 and from the command line.
.. CTRL-F5 or F5
.. ``dotnet run --server.urls http://*:5000``

==== Push to CloudFoundry
. Using the skills you learned from Lab05, publish and push the app to a Linux cell on Cloud Foundry.
.. ``dotnet publish -o %CD%\publish -f netcoreapp1.1 -r ubuntu.14.04-x64``
.. ``cf push -f manifest.yml -p .\publish``

=== Modify Fortune Teller UI

==== Step 01 - Modify FortuneController to use the IFortuneService
. To get the ``IFortuneService`` into the controller we need to add a constructor to the ``FortuneController``:
+
----
        private IFortuneService _fortunes;
        public FortunesController(IFortuneService fortunes)
        {
            _fortunes = fortunes;
        }
----
. Then to get ``FortuneController`` to use the ``IFortuneService`` we have to modify the contoller action:
+
----
        public async Task<IActionResult> RandomFortune()
        {
            var fortune = await _fortunes.RandomFortuneAsync();
            return View(fortune);
        }
----

==== Step 02 - Add IFortuneService to Service Container
. To get the ``IFortuneService`` into the service container we need to modify the ``Startup`` class method ``ConfigureServices`` and add ``IFortuneService`` as a Singleton created from its implementation ``FortuneServiceClient``.
+
----
        public void ConfigureServices(IServiceCollection services)
        {
            .....
            services.AddSingleton<IFortuneService, FortuneServiceClient>();
            ....
        }
----

==== Run Locally
. Using the skills you learned from Lab05, run the app from VS2015 and from the command line.
.. CTRL-F5 or F5
.. ``dotnet run --server.urls http://*:5555``

==== Push to CloudFoundry
. Using the skills you learned from Lab05, publish and push the app to a Linux cell on Cloud Foundry.
.. ``dotnet publish -o %CD%\publish -f netcoreapp1.1 -r ubuntu.14.04-x64``
.. ``cf push -f manifest.yml -p .\publish``

