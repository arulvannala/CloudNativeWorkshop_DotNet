= Lab 09 - Scaling and Steeltoe Connectors

[abstract]
--
In this lab we will continue to add functionality to the Fortune Teller application.
We will explore some of the existing horizontal scaling issues with the app and how Steeltoe connectors and data protection providers can help solve those issues.

If you started with the _FortuneTeller.sln_, and completed Lab 8, you have an app that is still not where we would like it to be:

. The ``Fortune Teller Service`` can not scale horizontally, as it uses a backend in-memory datastore to hold Fortunes.
. The ``Fortune Teller UI`` can not scale horizontally, as its session state (i.e. Users Fortune) will get lost.

The goals for Lab 8 are to:
. Understand ASP.NET Core Session services.
. Understand ASP.NET Core Data Protection services
. Use Steeltoe MySql Connector to bind the ``FortuneContext`` with a  MySql database.
. Use Steeltoe Redis Connector to cause the ASP.NET Core Session to use Redis for its Session storage.
. Use Steeltoe Redis Connector to cause the ASP.NET Core Data Protection service to use Redis to store its key ring.

For some background information on ASP.NET Core Sessions, have a look at this https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state[documentation].

For some background information on ASP.NET Core Data Protection, have a look at this https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/introduction[documentation].
--

== Open VS2015 Solution
. Start VS2015 and open the solution you wish to use:
.. _Workshop/Session-03/Lab09.sln_ if you want to start with finished code.
.. _Workshop/FortuneTeller/FortuneTeller.sln_ if you are writing code from scratch.

== Understanding ASP.NET Core Sessions and Data Protection
. Expand the ``Fortune-Teller-UI`` project
. Open and examine ``Startup``, as this is where the ASP.NET Core Session middleware is setup
.. Examine ``ConfigurationBuilder`` and ``SetBasePath``
.. Examine ``AddJsonFile()`` methods.  These are adding Configuration sources to the ``ConfigurationBuilder``.
... Notice the  ``AddEnvironmentVariables()`` as another provider added to builder.
... Explain Environments (e.g. development, staging, etc) and ``IHostingEnvironment.EnvironmentName``
... Explain setting Environments using ``ASPNETCORE_ENVIRONMENT`` and point out ``launchSettings.json``
.. Examine the arguments to ``AddJsonFile``
.. Notice ``appsettings-<<EnvironmentName>>.json`` is not present.
.. Notice ``Configuration = builder.Build()``. It actually builds the configuration at this point.
... Explain how one providers configuration values can override the others.
.. Open ``appsettings.json``. Current contents is used to configuring logging.
... Notice ``loggerFactory.AddConsole(...)`` in ``Configure`` method.

== Use Steeltoe MySQL Connector
In this exercise we will be adding code to the ``Fortune Teller Service`` to make use of the Steeltoe MySQL connector.

=== Step 01 - Run Spring Cloud Eureka Server Locally
We are still using the Eureka Server, so we need to make sure it is still running locally so its easier to development and test with.

. To run Eureka Server you will need Java JDK installed on your machine and the JAVA_HOME environment variable set to the JDK's installed location:
+
----
e.g. JAVA_HOME=C:\Program Files\Java\jdk1.8.0_112
----

. Open a command window.
. Change directory to _Workshop/EurekaServer_
+
----
> cd Workshop\EurekaServer
----

. Startup the eureka server
+
----
> mvnw spring-boot:run
----
{sp}+
It will start up on port 8761 and serve the Eureka API from "/eureka".

=== Step 02 - Run Spring Cloud Config Server Locally
We are still using the Config Server, so we need to make sure it is still running locally so its easier to development and test with.

. To run Config Server you will need Java JDK installed on your machine and the JAVA_HOME environment variable set to the JDK's installed location:
+
----
e.g. JAVA_HOME=C:\Program Files\Java\jdk1.8.0_112
----

. Open a command window.
. Create the directory _c:/steeltoe/config-repo_ if you haven't already done so.
 This will be the location the Config Server reads its configuration data from.
+
----
 > mkdir c:\steeltoe\config-repo
----

. Change directory to _Workshop/ConfigServer_
+
----
> cd Workshop\ConfigServer
----

. Startup the config server
+
----
> mvnw spring-boot:run
----
{sp}+
It will start up on port 8888 and serve configuration data from "file:///steeltoe/config-repo"

=== Step 03 - Add Steeltoe MySql Connector Nuget
Here we add the appropriate Steeltoe MySql Connector Nuget to the ``Fortune Teller Service``.
You will make use of the Nuget: ``Steeltoe.CloudFoundry.Connector.MySql``.

. Expand the ``Fortune-Teller-Service`` project.
. Open ``project.json`` and add the following line to the ``dependencies``:
..  "Steeltoe.CloudFoundry.Connector.MySql": "1.0.0-rc2"
+
----
"dependencies": {
   .......
   "Microsoft.EntityFrameworkCore": "1.0.2",
    "Microsoft.EntityFrameworkCore.InMemory": "1.0.2",
    "Pivotal.Extensions.Configuration.ConfigServer": "1.0.0-rc2",
    "Steeltoe.CloudFoundry.Connector.MySql": "1.0.0-rc2"
    },
    ......
----
. Save project.json and notice that a ``dotnet restore`` is done for you.

=== Step 04 - Add Steeltoe MySql Connector
Next we need to configure the ``DbContext`` to use MySql.
Remember we did that in the ``Startup`` class; in the ``ConfigureServices`` method where the service container is setup.

. Expand the ``Fortune-Teller-Service`` project
. Open ``Startup`` and locate the ``ConfigureServices()`` method. You should see something like the following:

----
public void ConfigureServices(IServiceCollection services)
{
    services.AddEntityFramework()
            .AddDbContext<FortuneContext>(options => options.UseInMemoryDatabase());

    services.AddSingleton<IFortuneRepository, FortuneRepository>();

    // Add framework services.
    services.AddMvc();
}
----

Ideally, if we were running an instance of MySQL locally on our desktop, we would just like to use it when we launch the app locally, in ``development`` mode.
If that were the case then we could simply change the ``.AddDbContext<FortuneContext>()`` call above to use MySql instead of the InMemory database and then configure the Steeltoe Connector in ``appsettings`` to use it.
The code and configuration would look something like below.
With this code, the Steeltoe Connector would use the configuration (i.e. ``appsettings``) when launched locally, but then would override its configuration with the MySql service binding when pushed to Cloud Foundry.

----
public void ConfigureServices(IServiceCollection services)
{
   services.AddEntityFramework()
         .AddDbContext<FortuneContext>(options => options.UseMySql(Configuration));
    services.AddSingleton<IFortuneRepository, FortuneRepository>();

    // Add framework services.
    services.AddMvc();
}
----

----
{
  "spring": {
    "application": {
      "name": "fortuneService"
    },
    "cloud": {
      "config": {
        "uri": "http://localhost:8888",
        "validate_certificates": false
      }
    }
  },
  "mysql": {
    "client": {
      "database": "mydatabase",
      "username": "username",
      "password": "password"
    }
  }
}
----
But since we are not running MySQL locally, we will instead configure things to use an In-Memory database when in ``development`` mode, but then use a MySql database when in any other.
To do that we will modify the ``ConfigureServices()`` method as follows:
----
public void ConfigureServices(IServiceCollection services)
{
    if (Environment.IsDevelopment())
    {
        services.AddEntityFramework()
                .AddDbContext<FortuneContext>(options => options.UseInMemoryDatabase());
    } else
    {
        services.AddEntityFramework()
             .AddDbContext<FortuneContext>(options => options.UseMySql(Configuration));
    }

    services.AddSingleton<IFortuneRepository, FortuneRepository>();

    // Add framework services.
    services.AddMvc();
}
----
=== Step 05 - Run Locally
At this point you should be ready to run both Fortune-Tellers locally and test.
Every thing should work as it did before, as you will still be using the In-Memory database when running locally.
In an upcoming exercise, we will push the Fortune-Tellers to Cloud Foundry and test the MySql connection.

. Using the skills you picked up in Lab05, run the apps from VS2015 and from the command line.
.. CTRL-F5 or F5
.. ``dotnet run --server.urls http://*:5000``
.. ``dotnet run --server.urls http://*:5555``

== Use Redis for Session Storage
In this exercise we will be adding code to the ``Fortune Teller UI`` to make use of the Steeltoe Redis connector.
We will use it to hook up the ASP.NET Core DistributedCache to a Redis service instance.

=== Step 01 - Run Spring Cloud Eureka Server Locally
We are still using the Eureka Server, so make sure it is still running locally.
See above if its not!

=== Step 02 - Run Spring Cloud Config Server Locally
We are still using the Config Server, so make sure it is still running locally.
See above if its not!

=== Step 03 - Add Steeltoe Redis Connector Nuget
Here we add the appropriate Steeltoe Redis Connector Nuget to the ``Fortune Teller UI``.
You will make use of the Nuget: ``Steeltoe.CloudFoundry.Connector.Redis``.

. Expand the ``Fortune-Teller-UI`` project.
. Open ``project.json`` and add the following line to the ``dependencies``:
..  "Steeltoe.CloudFoundry.Connector.Redis": "1.0.0-rc2"
+
----
"dependencies": {
   .......
    "Microsoft.Extensions.Options.ConfigurationExtensions": "1.1.0",
    "Pivotal.Discovery.Client": "1.0.0-rc2",
    "Pivotal.Extensions.Configuration.ConfigServer": "1.0.0-rc2",
    "Steeltoe.CloudFoundry.Connector.Redis": "1.0.0-rc2",
    },
    ......
----
. Save ``project.json`` and notice that a ``dotnet restore`` is done for you.

=== Step 04 - Add Steeltoe Redis Connector
Currently the ``Fortune-Teller-UI`` is using an In-memory cache for its session storage.
To see how this is currently setup to work:

. Expand the ``Fortune-Teller-UI`` project
. Open ``Startup`` and locate the ``ConfigureServices()`` method. You should see something like the whats shown below.

----
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IFortuneService, FortuneServiceClient>();
    services.Configure<FortuneServiceConfig>(Configuration.GetSection("fortuneService"));
    services.AddDiscoveryClient(Configuration);

    // Add framework services.
    services.AddDistributedMemoryCache();

    services.AddSession();

    services.AddMvc();
}
----

Like the case above with MySql, if we were running an instance of Redis locally on our desktop, we would just like to use it when we launch the app locally, in ``development`` mode.
If that were the case then we could simply change the ``. services.AddDistributedMemoryCache()`` call above to use a DistributedRedisCache instead of the InMemory cache and then configure the Steeltoe Connector in ``appsettings`` to use it.
The code and configuration would look something like that shown below.
With this code, the Steeltoe Connector would use the configuration (i.e. ``appsettings``) when launched locally, but then would override its configuration with the Redis service binding when pushed to Cloud Foundry.

----
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IFortuneService, FortuneServiceClient>();
    services.Configure<FortuneServiceConfig>(Configuration.GetSection("fortuneService"));
    services.AddDiscoveryClient(Configuration);

    // Add framework services.
    services.AddDistributedMemoryCache();

    services.AddSession();

    services.AddMvc();
}
----

----
{
  "spring": {
    "application": {
      "name": "fortuneui"
    },
    "cloud": {
      "config": {
        "uri": "http://localhost:8888",
        "validate_certificates": false
      }
    }
  },
  "redis": {
    "client": {
      "host": "http://foo.bar",
      "port": 1111
    }
  }
}
----
But, just like the case with MySQL, we are not running Redis locally, so we will instead have to configure things similar to MySql.
That is to use an In-Memory database when in ``development`` mode, but then use a Redis cache when in any other.
To do that we will modify the ``ConfigureServices()`` method as follows:
----
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IFortuneService, FortuneServiceClient>();
    services.Configure<FortuneServiceConfig>(Configuration.GetSection("fortuneService"));
    services.AddDiscoveryClient(Configuration);

    // Add framework services.

    if (Environment.IsDevelopment())
    {
        services.AddDistributedMemoryCache();
    }
    else
    {
        // Use Redis cache to store session data
        services.AddDistributedRedisCache(Configuration);
    }

    services.AddSession();

    services.AddMvc();
}
----

=== Step 05 - Run Locally
At this point you should be ready to run both Fortune-Tellers locally and test.
Every thing should work as it did before, as you will still be using the In-Memory cache when running locally.
In an upcoming exercise, we will push the Fortune-Tellers to Cloud Foundry and test the cache connection.

. Using the skills you picked up in Lab05, run the apps from VS2015 and from the command line.
.. CTRL-F5 or F5
.. ``dotnet run --server.urls http://*:5000``
.. ``dotnet run --server.urls http://*:5555``

== Use Redis for Data Protection Key Storage
In this exercise we will be adding code to the ``Fortune Teller UI`` to make use of the Steeltoe Redis connector.
We will use it to hook up the ASP.NET Core DistributedCache to a Redis service instance.

=== Step 01 - Run Spring Cloud Eureka Server Locally
We are still using the Eureka Server, so make sure it is still running locally.
See above if its not!

=== Step 02 - Run Spring Cloud Config Server Locally
We are still using the Config Server, so make sure it is still running locally.
See above if its not!

=== Step 03 - Add Steeltoe Redis Connector Nuget
Here we add the appropriate Steeltoe Redis Connector Nuget to the ``Fortune Teller UI``.
You will make use of the Nuget: ``Steeltoe.CloudFoundry.Connector.Redis``.

. Expand the ``Fortune-Teller-UI`` project.
. Open ``project.json`` and add the following line to the ``dependencies``:
..  "Steeltoe.CloudFoundry.Connector.Redis": "1.0.0-rc2"
+
----
"dependencies": {
   .......
    "Microsoft.Extensions.Options.ConfigurationExtensions": "1.1.0",
    "Pivotal.Discovery.Client": "1.0.0-rc2",
    "Pivotal.Extensions.Configuration.ConfigServer": "1.0.0-rc2",
    "Steeltoe.CloudFoundry.Connector.Redis": "1.0.0-rc2",
    },
    ......
----
. Save ``project.json`` and notice that a ``dotnet restore`` is done for you.

=== Step 04 - Add Steeltoe Redis Connector
Currently the ``Fortune-Teller-UI`` is using an In-memory cache for its session storage.
To see how this is currently setup to work:

. Expand the ``Fortune-Teller-UI`` project
. Open ``Startup`` and locate the ``ConfigureServices()`` method. You should see something like the whats shown below.

----
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IFortuneService, FortuneServiceClient>();
    services.Configure<FortuneServiceConfig>(Configuration.GetSection("fortuneService"));
    services.AddDiscoveryClient(Configuration);

    // Add framework services.
    services.AddDistributedMemoryCache();

    services.AddSession();

    services.AddMvc();
}
----

Like the case above with MySql, if we were running an instance of Redis locally on our desktop, we would just like to use it when we launch the app locally, in ``development`` mode.
If that were the case then we could simply change the ``. services.AddDistributedMemoryCache()`` call above to use a DistributedRedisCache instead of the InMemory cache and then configure the Steeltoe Connector in ``appsettings`` to use it.
The code and configuration would look something like that shown below.
With this code, the Steeltoe Connector would use the configuration (i.e. ``appsettings``) when launched locally, but then would override its configuration with the Redis service binding when pushed to Cloud Foundry.

----
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IFortuneService, FortuneServiceClient>();
    services.Configure<FortuneServiceConfig>(Configuration.GetSection("fortuneService"));
    services.AddDiscoveryClient(Configuration);

    // Add framework services.
    services.AddDistributedMemoryCache();

    services.AddSession();

    services.AddMvc();
}
----

----
{
  "spring": {
    "application": {
      "name": "fortuneui"
    },
    "cloud": {
      "config": {
        "uri": "http://localhost:8888",
        "validate_certificates": false
      }
    }
  },
  "redis": {
    "client": {
      "host": "http://foo.bar",
      "port": 1111
    }
  }
}
----
But, just like the case with MySQL, we are not running Redis locally, so we will instead have to configure things similar to MySql.
That is to use an In-Memory database when in ``development`` mode, but then use a Redis cache when in any other.
To do that we will modify the ``ConfigureServices()`` method as follows:
----
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IFortuneService, FortuneServiceClient>();
    services.Configure<FortuneServiceConfig>(Configuration.GetSection("fortuneService"));
    services.AddDiscoveryClient(Configuration);

    // Add framework services.

    if (Environment.IsDevelopment())
    {
        services.AddDistributedMemoryCache();
    }
    else
    {
        // Use Redis cache to store session data
        services.AddDistributedRedisCache(Configuration);
    }

    services.AddSession();

    services.AddMvc();
}
----

=== Step 05 - Run Locally
At this point you should be ready to run both Fortune-Tellers locally and test.
Every thing should work as it did before, as you will still be using the In-Memory cache when running locally.
In an upcoming exercise, we will push the Fortune-Tellers to Cloud Foundry and test the cache connection.

. Using the skills you picked up in Lab05, run the apps from VS2015 and from the command line.
.. CTRL-F5 or F5
.. ``dotnet run --server.urls http://*:5000``
.. ``dotnet run --server.urls http://*:5555``



== Deploy to Cloud Foundry

=== Step 01 - Setup MySql Server Instance
You must first create an instance of the MySql Server service in your org/space.

. Open a command window.
. Using the command window, create an instance of the MySql service:
+
----
> cf create-service p-mysql 100mb myMySqlService
----

=== Step 02 - Setup Redis Server Instance
You must first create an instance of the Redis service in your org/space.

. Open a command window.
. Using the command window, create an instance of the Redis service:
+
----
> cf create-service p-redis shared-vm myRedisService
----

==== Step 03 - Push to Cloud Foundry
. Examine the ``manfest.yml`` files for both projects and notice ``services`` addition shown below.
You need to make this change in your ``manifest.yml`` before you push to Cloud Foundry.
Also, notice the ``ASPNETCORE_ENVIRONMENT`` setting.
Feel free to change that to ``development`` if you want to turn on debug logging.
+
----
---
applications:
- name: fortuneService
  random-route: true
  memory: 512M
  buildpack: https://github.com/cloudfoundry-community/asp.net5-buildpack.git
  command: ./Fortune-Teller-Service --server.urls "http://*:$PORT"
  env:
    ASPNETCORE_ENVIRONMENT: production
  services:
   - myConfigServer
   - myMySqlService
   - myDiscoveryService
---
applications:
- name: fortuneui
  random-route: true
  memory: 512M
  buildpack: https://github.com/cloudfoundry-community/asp.net5-buildpack.git
  command: ./Fortune-Teller-UI --server.urls "http://*:$PORT"
  env:
    ASPNETCORE_ENVIRONMENT: production
  services:
   - myConfigServer
   - myDiscoveryService
   - myRedisService
----
. Using the skills you picked from Lab05, publish and push the components to a Linux cell on Cloud Foundry.
.. ``dotnet publish -o %CD%\publish -f netcoreapp1.1 -r ubuntu.14.04-x64``
.. ``cf push -f manifest.yml -p .\publish``